// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: todo_tags.sql

package db

import (
	"context"
)

const createTodoTag = `-- name: CreateTodoTag :exec
INSERT INTO todo_tags (todo_id, tag_id)
VALUES ($1, $2)
`

type CreateTodoTagParams struct {
	TodoID int32 `json:"todoId"`
	TagID  int32 `json:"tagId"`
}

func (q *Queries) CreateTodoTag(ctx context.Context, arg CreateTodoTagParams) error {
	_, err := q.db.Exec(ctx, createTodoTag, arg.TodoID, arg.TagID)
	return err
}

const deleteAllTagTodos = `-- name: DeleteAllTagTodos :exec
DELETE FROM todo_tags
WHERE tag_id = $1
`

func (q *Queries) DeleteAllTagTodos(ctx context.Context, tagID int32) error {
	_, err := q.db.Exec(ctx, deleteAllTagTodos, tagID)
	return err
}

const deleteAllTodoTags = `-- name: DeleteAllTodoTags :exec
DELETE FROM todo_tags
WHERE todo_id = $1
`

func (q *Queries) DeleteAllTodoTags(ctx context.Context, todoID int32) error {
	_, err := q.db.Exec(ctx, deleteAllTodoTags, todoID)
	return err
}

const deleteTodoTag = `-- name: DeleteTodoTag :exec
DELETE FROM todo_tags
WHERE todo_id = $1 AND tag_id = $2
`

type DeleteTodoTagParams struct {
	TodoID int32 `json:"todoId"`
	TagID  int32 `json:"tagId"`
}

func (q *Queries) DeleteTodoTag(ctx context.Context, arg DeleteTodoTagParams) error {
	_, err := q.db.Exec(ctx, deleteTodoTag, arg.TodoID, arg.TagID)
	return err
}

const getTagTodos = `-- name: GetTagTodos :many
SELECT todo_id, tag_id FROM todo_tags
WHERE tag_id = $1
`

func (q *Queries) GetTagTodos(ctx context.Context, tagID int32) ([]TodoTag, error) {
	rows, err := q.db.Query(ctx, getTagTodos, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TodoTag{}
	for rows.Next() {
		var i TodoTag
		if err := rows.Scan(&i.TodoID, &i.TagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTodoTags = `-- name: GetTodoTags :many
SELECT todo_id, tag_id FROM todo_tags
WHERE todo_id = $1
`

func (q *Queries) GetTodoTags(ctx context.Context, todoID int32) ([]TodoTag, error) {
	rows, err := q.db.Query(ctx, getTodoTags, todoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TodoTag{}
	for rows.Next() {
		var i TodoTag
		if err := rows.Scan(&i.TodoID, &i.TagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTodoTagsByTodo = `-- name: ListTodoTagsByTodo :many
SELECT t.tag_id, t.user_id, t.name, t.color, t.created_at FROM tags t
JOIN todo_tags tt ON t.tag_id = tt.tag_id
WHERE tt.todo_id = $1
ORDER BY t.name ASC
`

func (q *Queries) ListTodoTagsByTodo(ctx context.Context, todoID int32) ([]Tag, error) {
	rows, err := q.db.Query(ctx, listTodoTagsByTodo, todoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.TagID,
			&i.UserID,
			&i.Name,
			&i.Color,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTodosByTag = `-- name: ListTodosByTag :many
SELECT td.todo_id, td.user_id, td.project_id, td.parent_todo_id, td.title, td.description, td.is_completed, td.due_date, td.work_start_time, td.work_end_time, td.priority, td.created_at, td.updated_at, td.completed_at FROM todos td
JOIN todo_tags tt ON td.todo_id = tt.todo_id
WHERE tt.tag_id = $1
ORDER BY td.created_at DESC
`

func (q *Queries) ListTodosByTag(ctx context.Context, tagID int32) ([]Todo, error) {
	rows, err := q.db.Query(ctx, listTodosByTag, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Todo{}
	for rows.Next() {
		var i Todo
		if err := rows.Scan(
			&i.TodoID,
			&i.UserID,
			&i.ProjectID,
			&i.ParentTodoID,
			&i.Title,
			&i.Description,
			&i.IsCompleted,
			&i.DueDate,
			&i.WorkStartTime,
			&i.WorkEndTime,
			&i.Priority,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
